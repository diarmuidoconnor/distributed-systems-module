## SES service.

The second part of our fan out implementation is a lambda function that sends an email to a verified identity. Recall that in the Cognito lab, we declared email accounts we own, termed verified identities in AWS. We will use these to test our lambda's functionality. We are now expanding the implementation as illustrated by the red line area in the diagram below:

![][ses]

In `lib/eda-app-stack.ts`, make the following changes:

+ Add a second queue:
~~~ts
    const mailerQ = new sqs.Queue(this, "mailer-q", {
      receiveMessageWaitTime: cdk.Duration.seconds(10),
    });
~~~
+ Add a second lambda function:
~~~ts
   const mailerFn = new lambdanode.NodejsFunction(this, "mailer", {
      runtime: lambda.Runtime.NODEJS_16_X,
      memorySize: 1024,
      timeout: cdk.Duration.seconds(3),
      entry: `${__dirname}/../lambdas/mailer.ts`,
    });
~~~
+ Make the new queue a subscriber to the SNS topic:
~~~ts
    newImageTopic.addSubscription(new subs.SqsSubscription(mailerQ));
~~~
+ Create an event source from the new SQS queue:
~~~ts
    const newImageMailEventSource = new events.SqsEventSource(mailerQ, {
      batchSize: 5,
      maxBatchingWindow: cdk.Duration.seconds(5),
    }); 
~~~
+ Make the new event source the trigger for the new lambda function:
~~~ts
mailerFn.addEventSource(newImageMailEventSource);
~~~
+ Give the new lambda function permission to send emails using the SES service:
~~~ts
  mailerFn.addToRolePolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: [
          "ses:SendEmail",
          "ses:SendRawEmail",
          "ses:SendTemplatedEmail",
        ],
        resources: ["*"],
      })
    );
~~~
We will simplify the emailing logic in this lab by using the same destination mail address for each image upload. Create a file in the base folder called `env.ts` and add the following code:
~~~ts
export const SES_REGION = 'eu-west-1';
export const SES_EMAIL_FROM = 'verified-identity-1' ;
export const SES_EMAIL_TO =  'verified-identity-2';
~~~
__NOTE__: The verified identities must be email addresses verified in your AWS account.

Create a new file for the lambda function called `lambdas/mailer.ts` and paste in the following code:
~~~ts
import { SQSHandler } from "aws-lambda";
import { SES_EMAIL_FROM, SES_EMAIL_TO, SES_REGION } from "../env";
import {
  SESClient,
  SendEmailCommand,
  SendEmailCommandInput,
} from "@aws-sdk/client-ses";

if (!SES_EMAIL_TO || !SES_EMAIL_FROM || !SES_REGION) {
  throw new Error(
    "Please add the SES_EMAIL_TO, SES_EMAIL_FROM and SES_REGION environment variables in an env.js file located in the root directory"
  );
}

type ContactDetails = {
  name: string;
  email: string;
  message: string;
};

const client = new SESClient({ region: SES_REGION});

export const handler: SQSHandler = async (event: any) => {
  console.log("Event ", JSON.stringify(event));
  for (const record of event.Records) {
    const recordBody = JSON.parse(record.body);
    const snsMessage = JSON.parse(recordBody.Message);

    if (snsMessage.Records) {
      console.log("Record body ", JSON.stringify(snsMessage));
      for (const s3Mmessage of snsMessage.Records) {
        const s3e = s3Message.s3;
        const srcBucket = s3e.bucket.name;
        // Object key may have spaces or unicode non-ASCII characters.
        const srcKey = decodeURIComponent(s3e.object.key.replace(/\+/g, " "));
        try {
          const { name, email, message }: ContactDetails = {
            name: "The Photo Album",
            email: SES_EMAIL_FROM,
            message: `We received your Image. Its URL is s3://${srcBucket}/${srcKey}`,
          };
          const params = sendEmailParams({ name, email, message });
          await client.send(new SendEmailCommand(params));
        } catch (error: unknown) {
          console.log("ERROR is: ", error);
          // return;
        }
      }
    }
  }
};

function sendEmailParams({ name, email, message }: ContactDetails) {
  const parameters: SendEmailCommandInput = {
    Destination: {
      ToAddresses: [SES_EMAIL_TO],
    },
    Message: {
      Body: {
        Html: {
          Charset: "UTF-8",
          Data: getHtmlContent({ name, email, message }),
        },
        // Text: {.           // For demo purposes
        //   Charset: "UTF-8",
        //   Data: getTextContent({ name, email, message }),
        // },
      },
      Subject: {
        Charset: "UTF-8",
        Data: `New image Upload`,
      },
    },
    Source: SES_EMAIL_FROM,
  };
  return parameters;
}

function getHtmlContent({ name, email, message }: ContactDetails) {
  return `
    <html>
      <body>
        <h2>Sent from: </h2>
        <ul>
          <li style="font-size:18px">üë§ <b>${name}</b></li>
          <li style="font-size:18px">‚úâÔ∏è <b>${email}</b></li>
        </ul>
        <p style="font-size:18px">${message}</p>
      </body>
    </html> 
  `;
}

 // For demo purposes - not used here.
function getTextContent({ name, email, message }: ContactDetails) {
  return `
    Received an Email. üì¨
    Sent from:
        üë§ ${name}
        ‚úâÔ∏è ${email}
    ${message}
  `;
}
~~~
The above  handler has the same outline structure as the processImage handler, i.e. nested for loop to iterate over the S3 image upload messages inside each SNS message. We send an email for each upload occurrence. 

Redeploy the stack and test it with the following upload:
~~~bash
¬£ aws s3 cp ./images/sunflower.jpeg  s3://your_bucket_name/image3.jpeg
~~~
Check the email account you used for SES_EMAIL_TO to confirm an email was received:

![][email]

In Cloudwatch, check the log group for both lambda functions to confirm they executed for the above upload operation. 

Commit this work:
~~~bash
$ git add -A
$ git commit -m "Completed Fan out implementation - added emailing logic"
$ git push origin master
~~~

### Additional functionality.

We will extend the processImage lambda function to record each uploaded image in a simple DynamoDB table whose partition key is the image file name. 

In `eda-stack.ts`:

+ Add an import:
~~~ts
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
~~~
+ Add the table definition:
~~~ts
    const imagesTable = new dynamodb.Table(this, "ImagesTable", {
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
      partitionKey: { name: "name", type: dynamodb.AttributeType.STRING },
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      tableName: "Imagess",
 });
~~~
+ Update the lambda function:
~~~ts
    const processImageFn = new lambdanode.NodejsFunction(
      this,
      "ProcessImageFn",
 {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: `${__dirname}/../lambdas/processImage.ts`,
        timeout: cdk.Duration.seconds(15),
        memorySize: 128,
        environment: {
          TABLE_NAME: imagesTable.tableName,
          BUCKET_NAME: imagesBucket.bucketName,
          REGION: 'eu-west-1'
 },
 }
 );
~~~
+ Add permissions to the function:
~~~ts
    imagesTable.grantReadWriteData(processImageFn);
~~~

In `processImage.ts`:
+ Add some imports:
~~~ts
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, PutCommand } from "@aws-sdk/lib-dynamodb";
~~~
+ Add initialisation code:
~~~ts
const ddbDocClient = createDDbDocClient();
~~~
+ Add the private function at the bottom:
~~~ts

function createDDbDocClient() {
  const ddbClient = new DynamoDBClient({ region: process.env.REGION });
  const marshallOptions = {
    convertEmptyValues: true,
    removeUndefinedValues: true,
    convertClassInstanceToMap: true,
 };
  const unmarshallOptions = {
    wrapNumbers: false,
 };
  const translateConfig = { marshallOptions, unmarshallOptions };
  return DynamoDBDocumentClient.from(ddbClient, translateConfig);
}
~~~
+ In the main handler function, replace the try-catch block for downloading the image with a database write statement:
~~~ts
    await ddbDocClient.send(
      new PutCommand({
        TableName: process.env.TABLE_NAME,
        Item: {
          name: srcKey
 },
 })
 );
~~~

Deploy the stack updates, and upload another image:
~~~

~~~
In the DynamoDB management console, verify that an item was added to the table‚Äîit consists of only one property: the image file name. 


[email]: ./img/email.png
[ses]: ./img/ses.png

