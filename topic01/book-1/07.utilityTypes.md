## Utility Types.

In `src/myTypes.d.ts` declare three new types:
~~~ts
export type FriendPartial = Partial<Friend>

export type EventPass = Omit<Colleague, "contact"> & {
  passCode : number;
}
export type SecureFriendContact = Readonly<Pick<Friend,"name" | "phone" > >
~~~
The FriendPartial type has the same structure as Friend but all its properties are optional. The EventPass types has the same properties as Colleague except for contact, and has an additional property, called passCode. The SecureFriendContact ty=e demonstrates composition of the utility types. It generates a type with the same structure as Friend except for age and dob. However, instances of this type are immutable.

Create the file `src/05-utilityTypes.ts` and add the following code:
~~~ts
import { friends, colleagues } from "./01-basics";
import { Friend, Colleague, SecureFriendContact, FriendPartial } from "./myTypes";

function updateFriend(friend: Friend, updates: FriendPartial ) : Friend {
  return { ...friend, ...updates}
}

console.log(updateFriend(friends[0], {
  phone: '08712345',
  dob: new Date("1998-10-22")
}))
~~~
Examine the code and run the script.

Add the following to the end of `05-utilityTypes.ts`:
~~~ts
function secureFindFriends(
  friends: Friend[],
  criteria: (f: Friend) => boolean
): SecureFriendContact[] {
  const matches = friends.filter(criteria);
  return matches.map((f) => {
    const secure: SecureFriendContact = {
      name: f.name,
      phone: f.phone,
    };
    return secure;
  });
}
let result = secureFindFriends(
    friends,
    (f: Friend) => f.age < 30
)
console.log(result)
~~~
The new function searches through an array of friends for matches. A readonly copy of each matching object is added to a new array and returned. To prove the response is readonly, add the following line after the console.log:
~~~ts
result[0].phone = '08654321'
~~~
It causes the following error:

![][error] 

To demonstrate the new EventPass type, suppose we want a function that generates a pass code for a colleague to allow them entry to an event. Add this code to the script file and run it to see its output:
~~~ts
function generateEventPass(colleague: Colleague): EventPass {
  const passCode = Math.round(Math.random() * (1000 - 1) + 1);
  return {
    name: colleague.name,
    department: colleague.department,
    passCode: passCode,
  };
}
console.log(generateEventPass(colleagues.current[0]));
~~~

The __incomplete__ function below finds the intersection of a friends arrsy and colleagues array, i.e. people whom are both a friend and a colleague. __You are required__ to complete the function so that it returns an array of objects with a mix of properties from the Friend and Colleagues types, as follows:

+ name
+ age
+ contact:
   + email
   + extension

~~~ts
function intersection(
  friends: Friend[],
  colleagues: Colleague[]
): ?? {
  let result ??
  friends.reduce((res, friend) => {
    const colleague = colleagues.find((col) => col.name === friend.name);
    if (colleague) {
      // Colleague is also a Friend
      ??
    }
    return res;
  }, result);
  return result;
}

console.log(intersection(friends, colleagues.current));
~~~

[error]: ./img/error.png
